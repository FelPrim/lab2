За счёт чего мы достигается оптимизация?
Обычно главный шаг оптимизации - это выбор правильного алгоритма. Т.к. алгоритм нам уже задан (BiCG), то этот шаг по сути пропускается (наверное, то, что программа использует BICGStab вместо BICG + подходящий для моего конкретного случая предобуславливатель можно считать оптимизацией на этом уровне?..)
Следующий шаг - распараллеливание и использование SIMD интринзиков (как перевести intrinsics???). Т.к. в нашем случае самая медленная часть работы программы - это умножение матрицы на вектор (линейного оператора), то это сделать весьма легко (надо лишь удостовериться, поддерживает ли компьютер интринзики и сколько потоков можно с него вытащить). Мой ноут поддерживает целых 2 потока и AVX2 (думаю, практически все современные процессоры его поддерживают), поэтому оптимизировать буду с учётом A потоков и поддержкой avx2. Использование avx, по сути, сделает элементы матрицы больше (а число элементов меньше). 
$$\begin{pmatrix}1 & 2 & 3 & 4 & 5 & 6 \\ 7 & 8 & 9 & 10 & 11& 12\\13 & 14&15&16&17&18\\19&20&21&22&23&24\\25&26&27&28&29&30 \end{pmatrix}\begin{pmatrix}1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6\end{pmatrix}=\begin{pmatrix}a \\ b \\ c \\ d \\ e\end{pmatrix}$$
Распараллеливание:
$$ \begin{pmatrix}\begin{pmatrix}1 & 2 & 3 & 4 & 5 & 6 \\ 7 & 8 & 9 & 10 & 11& 12\\13 & 14&15&16&17&18\end{pmatrix}\\ \begin{pmatrix}19&20&21&22&23&24\\25&26&27&28&29&30 \end{pmatrix}\end{pmatrix}\begin{pmatrix}1 \\ 2 \\ 3 \\ 4 \\ 5 \\ 6 \end{pmatrix}=\begin{pmatrix} \begin{pmatrix} a \\ b\\ c \end{pmatrix} \\ \begin{pmatrix} d \\ e \end{pmatrix}\end{pmatrix}$$
avx:
$$\begin{pmatrix}\begin{pmatrix}1 & 2 \\7 & 8 \end{pmatrix} & \begin{pmatrix} 3 & 4 \\ 9 & 10 \end{pmatrix} & \begin{pmatrix} 5 & 6 \\ 11 & 12 \end{pmatrix} \\
\begin{pmatrix} 13 & 14 \\ 19 & 20 \end{pmatrix} & \begin{pmatrix} 15& 16 \\ 21 & 22 \end{pmatrix} & \begin{pmatrix} 17 & 18 \\ 23 & 24\end{pmatrix} \\
\begin{pmatrix} 25 & 26  \end{pmatrix} & \begin{pmatrix} 27 & 28 \end{pmatrix} &\begin{pmatrix} 29 & 30 \end{pmatrix}\end{pmatrix}\begin{pmatrix} \begin{pmatrix} 1 \\ 2 \end{pmatrix}\\\begin{pmatrix} 3 \\ 4\end{pmatrix}\\\begin{pmatrix} 5 \\ 6\end{pmatrix}\end{pmatrix}=\begin{pmatrix} \begin{pmatrix}a \\ b \end{pmatrix} \\ \begin{pmatrix} c \\ d\end{pmatrix}\\ \begin{pmatrix} e\end{pmatrix}\end{pmatrix}$$

Я планирую использовать L1 и L3 кеши (или L2 если L3 нет). 

L1 кеш отводится под микрооперацию умножения матрицы размером C на C на вектор C. 1 Блок матрицы и 2 блока векторов (входной и выходной) занимают суммарно $8\cdot(C^2+2C) \approx 8(C+1)^2$. Т.к. обычно мы не можем использовать ресурсы компьютера на 100%, то в L1-кеше должно хоть что-то остаться. Допустим, что мы используем размер не более чем k\*L1 (L1 - размер L1 кеша) . Тогда 
$$8(C+1)^2 \leq k\cdot L_1$$
1 кеш не может быть супербольшим, то подходящие значения значения C можно заранее рассчитать (C также должно быть кратно 4):
Для кеша размером 128Кб (overkill) ближайшее такое C было б 112.

Соответственно, при умножении BCSR матрицы на вектор мы итерируем массив элементов матрицы. Распараллелить такое умножение просто - по строкам. Проблема лишь в том, что если мы распараллелим прям по строкам, то это не будет эффективно - в кеш потока может поместиться больше чем одна строка. Соответственно, план в том, чтобы сопоставить каждому потоку структуру из X последовательно идущих строк, которая поместится в его кеш.  
Предположим, для упрощения, что у исходной матрицы равномерное распределение числа элементов по строкам. Пусть исходная матрица была M на N. Значит, размер умножаемого вектора - M, размер результата - N. Число элементов исходной матрицы A.
Во-первых, мы знаем, что C - размер блока матрицы, поэтому одна строка матрицы, в среднем, будет занимать $8\frac{A}{N}C$. Полоса из X строк займёт память $8\frac{A}{N}CX$
Если структура состоит из X строк, то число таких "полос" $- \ \frac{N}{X}$.
Если мы выделяем из матрицы полосу, то мы знаем, что результат умножения вектора на эту полосу - это участок результирующего вектора, с таким же размером, что и полоса. Для того, чтобы мы могли провести эту операцию, умножаемый вектор нам нужен целиком.
Итого, для 1 такой операции расход памяти:
$$8\left(M+\frac{A}{N}CX+X\right)\leq k\cdot L_3$$
Как видим, к сожалению, так как на этапе компиляции нам не известны M, A и N, то мы не можем подобрать X константно - значит, мы найдём его в runtime.

$$M = \begin{pmatrix}
A_{11} & 0 & \cdots & 0 \\
0 & A_{22} & \cdots & 0 \\
\vdots & \vdots & \ddots & \vdots \\
0 & 0 & \cdots & A_{kk}
\end{pmatrix}$$

$$M = \begin{pmatrix}
B_{11} & 0 & \cdots & 0 \\
0 & B_{22} & \cdots & 0 \\
\vdots & \vdots & \ddots & \vdots \\
0 & 0 & \cdots & B_{kk}
\end{pmatrix}$$