Это алгоритм для приближенного решения СЛАУ в общем виде
BICGStab:
Псевдокод:
```
Дано: A, b (как иначе мы будем решать A*x=b?)
Также известны: M (предобуславливатель*), maxiter (ограничение на число итераций), tol (точность) и x0 (начальное приближение)
x = x0
r (невязка) = b - A*x0 // т.е. A*x0 + r = b
r0_hat = r //?
rho_prev = 1 // первоначальное скалярное произведение r и r0_hat
alpha = 1 //?
omega = 1 //?

p = 0 //?
v = 0 //?
norm_b = norm(b) // Норма правой части для критерия останова

for k = 1 to max_iter do:
	// Шаг 1: Обновление rho и проверка сходимости
	rho = dot(r0_hat, r) // Скалярное произведение
	if |rho| < eps:      // Деление на ноль -> сбой
		break
	
	// Шаг 2: Вычисление beta и p
	if k == 1:
		p = r
	else:
		beta = (rho / rho_prev) * (alpha / omega)
		p = r + beta * (p - omega * v)
	
	// Шаг 3: Решение с предобуславливателем
	p_hat = solve(M, p)        // M * p_hat = p
	
	// Шаг 4: Матрично-векторное умножение
	v = A * p_hat
	
	// Шаг 5: Вычисление alpha
	alpha = rho / dot(r0_hat, v)
	
	// Шаг 6: Промежуточная невязка
	s = r - alpha * v
	if norm(s) < tol * norm_b:  // Ранняя сходимость
		x = x + alpha * p_hat
		break
	
	// Шаг 7: Решение с предобуславливателем для s
	s_hat = solve(M, s)         // M * s_hat = s
	
	// Шаг 8: Матрично-векторное умножение
	t = A * s_hat
	
	// Шаг 9: Вычисление omega
	omega = dot(t, s) / dot(t, t)
	
	// Шаг 10: Обновление решения
	x = x + alpha * p_hat + omega * s_hat
	
	// Шаг 11: Обновление невязки
	r = s - omega * t
	
	// Проверка сходимости
	if norm(r) < tol * norm_b:
		break
	
	// Обновление для следующей итерации
	rho_prev = rho
	
end for
return x, k                     // Решение и число итераций

```